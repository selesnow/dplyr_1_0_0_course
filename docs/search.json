[{"path":"index.html","id":"введение","chapter":"Введение","heading":"Введение","text":"","code":""},{"path":"index.html","id":"о-курсе","chapter":"Введение","heading":"О курсе","text":"dplyr - один из наиболее популярных пакетов, который реализует грамматику манипуляции данными в языке R. Официально первый релиз dplyr был выпещен в 2014 году, но пакет развивался, и первая стабильная версия с устоявшимся синтаксисом, под номером 1.0.0 была выпущена весной 2020 года. Этому релизу предшествовала серия статей, в которых Хедли Викхем описывал все нововведения в dplyr. Этот мини курс появился из 5 видео уроков снятых по этим статьям.В основе видео уроков лежат следующие статьи:dplyr 1.0.0: select, rename, relocatedplyr 1.0.0: working across columnsdplyr 1.0.0: working within rowsdplyr 1.0.0: new summarise() featuresdplyr 1.0.0: last minute additions","code":""},{"path":"index.html","id":"для-кого-этот-курс","chapter":"Введение","heading":"Для кого этот курс","text":"Для прохождения курса вы уже должны иметь навыки работы с инфраструктурой tidyverse. Приступать к прохождению курса “Введение в dplyr 1.0.0” я советую тем, кто уже имеет базовые навыки работы в R. Т.е. изначально я рекомендую вам пройти курс “Язык R для пользователей Excel”, и потом приступать к прохождению данного курса.","code":""},{"path":"index.html","id":"рекомендации-по-прохождению-курса","chapter":"Введение","heading":"Рекомендации по прохождению курса","text":"Данный курс состоит из 5 видео уроков общей длительность 1 час 2 минуты. К каждому уроку есть рассмотренный в видео код, это сделано для вашего удобства, скопируйте его и выполняйте по мере просмотра видео лекции.","code":""},{"path":"index.html","id":"об-авторе","chapter":"Введение","heading":"Об авторе","text":"Меня зовут Алексей Селезнёв, с 2008 года я являюсь практикующим аналитиком. На данный момент основной моей деятельностью является развитие отдела аналитики в агентстве интернет-маркетинга Netpeak.\nМною были разработаны такие R пакеты как: ryandexdirect, rfacebookstat, timeperiodsR, rvkstat и некоторые другие. На данный момент написанные мной пакеты только с CRAN были установленны более 130 000 раз.Также я являюсь автором курса “Язык R для интернет-маркетинга”.Веду свой авторский Telegram и YouTube канал R4marketing. Буду рад видеть вас в рядах подписчиков.Периодически публикую статью на различных интернет медиа, зачастую это Хабр и Netpeak Journal.Неоднократно выступал на профильных конференциях по аналитике и интернет маркетингу, среди которых Матемаркетинг, GoAnalytics, Analyze, eCommerce, 8P и прочие.Начиная с 2016 года всячески стараюсь популяризировать язык R среди русскоязычных аналитиков и маркетологов. Этот курс также был создан с этой целью.","code":""},{"path":"index.html","id":"программа-курса","chapter":"Введение","heading":"Программа курса","text":"Функции select(), rename_with() и relocate()Функция across()Перебор строк функцией rowwise()Обновлённая функция summarise()Добавление, изменение и удаление строк дата фрейма через rows_*()","code":""},{"path":"index.html","id":"благодарности","chapter":"Введение","heading":"Благодарности","text":"Курс, и все сопутствующие материалы предоставляются бесплатно, но если у вас есть желание отблагодарить автора за этот видео курс вы можете перечислить любую произвольную сумму на этой странице.","code":""},{"path":"функции-select-rename_with-и-relocate.html","id":"функции-select-rename_with-и-relocate","chapter":"Урок 1 Функции select(), rename_with() и relocate()","heading":"Урок 1 Функции select(), rename_with() и relocate()","text":"","code":""},{"path":"функции-select-rename_with-и-relocate.html","id":"описание","chapter":"Урок 1 Функции select(), rename_with() и relocate()","heading":"1.1 Описание","text":"Первый урок курса посвящён таким операциям, как продвинутый выбор столбцов, их переименование и изменения порядка столбцов таблицы.В этом видео уроке мы познакомимся с такими функциями как: select(), rename_with(), relocate(), any_of(), all_of().В основе урока лежит статья “dplyr 1.0.0: select, rename, relocate”.","code":""},{"path":"функции-select-rename_with-и-relocate.html","id":"видео","chapter":"Урок 1 Функции select(), rename_with() и relocate()","heading":"1.2 Видео","text":"","code":""},{"path":"функции-select-rename_with-и-relocate.html","id":"код","chapter":"Урок 1 Функции select(), rename_with() и relocate()","heading":"1.3 Код","text":"","code":"\n#devtools::install_github(\"tidyverse/dplyr\")\nlibrary(dplyr, warn.conflicts = FALSE)\n\n# rename\n# Переименовать столбцы для устранение дублирования их имён\ndf1 <- tibble(a = 1:5, a = 5:1, .name_repair = \"minimal\")\ndf1\n\ndf1 %>% rename(b = 2)\n\n# select\n# обращение к столбцам по типу\ndf2 <- tibble(x1 = 1, x2 = \"a\", x3 = 2, y1 = \"b\", y2 = 3, y3 = \"c\", y4 = 4)\n\n# числовые столбцы\ndf2 %>% select(is.numeric)\n# НЕ текстовые столбцы\ndf2 %>% select(!is.character)\n\n# смешанный тип обращения\n# числовые стобцы, название которых начинается на X\ndf2 %>% select(starts_with(\"x\") & is.numeric)\n\n\n# выбор полей с помощью функций any_of и all_of\nvars <- c(\"x1\", \"x2\", \"y1\", \"z\")\ndf2 %>% select(any_of(vars))\n\ndf2 %>% select(all_of(vars))\n\n\n# функция rename_with\ndf2 %>% rename_with(toupper)\n\ndf2 %>% rename_with(toupper, starts_with(\"x\"))\n\ndf2 %>% rename_with(toupper, is.numeric)\n\n\n# relocate для изменения порядка стобцов\ndf3 <- tibble(w = 0, x = 1, y = \"a\", z = \"b\")\n# переместить столбцы y, z в начало\ndf3 %>% relocate(y, z)\n# переместить текстовые столбцы вначало\ndf3 %>% relocate(is.character)\n\n# поместить столбец w после y\ndf3 %>% relocate(w, .after = y)\n# поместить столбец w перед y\ndf3 %>% relocate(w, .before = y)\n# переместить w в конец\ndf3 %>% relocate(w, .after = last_col())"},{"path":"функции-select-rename_with-и-relocate.html","id":"упражнения","chapter":"Урок 1 Функции select(), rename_with() и relocate()","heading":"1.4 Упражнения","text":"Для примера мы будем использовать встроенный набор данных iris, выполните следующие действия:Выберите все столбцы, которые заканчиваются на Width.Переместите с помощью функции relocate() единственный текстовый столбец в левую часть таблицы.Замените с помощью функции rename_with() в названии столбцов точку на нижнее подчёркивание, и преобразуйте имена в нижний регистр.","code":""},{"path":"функция-across.html","id":"функция-across","chapter":"Урок 2 Функция across()","heading":"Урок 2 Функция across()","text":"","code":""},{"path":"функция-across.html","id":"описание-1","chapter":"Урок 2 Функция across()","heading":"2.1 Описание","text":"В этом уроке продемонстрирована работа с новой функцией across(), которая упрощает обращение к столбцам внутри таких функций как mutate() и summarise(). По сути функция across() заменяет функции с приставками *_at() , *_if(), *_all().Обзор основан на статье Хедли Викхема “dplyr 1.0.0: working across columns”.","code":""},{"path":"функция-across.html","id":"видео-1","chapter":"Урок 2 Функция across()","heading":"2.2 Видео","text":"","code":""},{"path":"функция-across.html","id":"код-1","chapter":"Урок 2 Функция across()","heading":"2.3 Код","text":"","code":"\n# devtools::install_github(\"tidyverse/dplyr\")\nlibrary(dplyr, warn.conflicts = FALSE)\n\n# тестовый дата фрейм\ndf <- tibble(g1 = as.factor(sample(letters[1:4],size = 10, replace = T )),\n             g2 = as.factor(sample(LETTERS[1:3],size = 10, replace = T )),\n             a  = runif(10, 1, 10),\n             b  = runif(10, 10, 20),\n             c  = runif(10, 15, 30),\n             d  = runif(10, 1, 50))\n\n# о чём пойдёт речь\n## копирование кода, когда требуется \n## произвести одну и туже операцию с разными функциями\ndf %>% \n  group_by(g1, g2) %>% \n  summarise(a = mean(a), b = mean(b), c = mean(c), d = mean(c))\n\n# новый способ\n## теперь для таких преобразований можно\n## использовать тот же синтаксис что и в select()\n### посчитать среднее по столбцам от a до d\ndf %>% \n  group_by(g1, g2) %>% \n  summarise(across(a:d, mean))\n\n### или посчитать среднее выбрав все числовые столбцы \ndf %>% \n  group_by(g1, g2) %>% \n  summarise(across(is.numeric, mean))\n\n# ##############################\n# Простой пример\n# аргументы функции accros\n\n## .cols - выбор столбцов по позиции, имени, функцией, типу данных, или комбинируя любые перечисленные способы\n## .fns - функция, или список функций которые необходимо применить к каждому столбцу\n\n## считаем количество униклаьных значений в текстовых полях\nstarwars %>% \n  summarise(across(is.character, n_distinct))\n\n## пример с фильтрацией данных\nstarwars %>% \n  group_by(species) %>% \n  filter(n() > 1) %>% \n  summarise(across(c(sex, gender, homeworld), n_distinct))\n\n## комбинируем accross с другими вычислениями\nstarwars %>% \n  group_by(homeworld) %>% \n  filter(n() > 1) %>% \n  summarise(across(is.numeric, mean, na.rm = TRUE), \n            n = n())\n\n# ##############################\n# Чем accross лучше предыдущих функций с суфиксами _at, _if, _all\n\n## 1. accross позволяет комбинировать различные вычисления внутри одной summarise \n## пример из статьи\ndf %>%\n  group_by(g1, g2) %>% \n  summarise(\n    across(is.numeric, mean), \n    across(is.factor, nlevels),\n    n = n(), \n  )\n\n## рабочий пример\nstarwars %>% \n  group_by(species) %>% \n  summarise(across(is.character, n_distinct), \n            across(is.numeric, mean), \n            across(is.list, length), \n            n = n()\n  )\n\n## 2. уменьшает количество необходимых функций в dplyr, что облегчает их запоминание\n## 3. объединяет возможности функций с суфиксами if_, at_, и даёт возможность объединять их возможности\n## 4. accross не требует от вас использования функции vars для указания нужных столбцлв, как это было раньше\n\n# ##############################\n# перевод старого кода на accross\n\n## для перевода функций с суфиксами _at, _if, _all используйте следующие правила\n### в accross первым агрументом будет:\n### Для *_if() старый второй аргумент.\n### Для *_at() старый второй аргумент с удаленным вызовом vars().\n### Для *_all(), в качестве первого аргумента передайте функцию everything()\n\n## примеры\ndf <- tibble(y_a  = runif(10, 1, 10),\n             y_b  = runif(10, 10, 20),\n             x    = runif(10, 15, 30),\n             d    = runif(10, 1, 50))\n\n### из _if в accross\ndf %>% mutate_if(is.numeric, mean, na.rm = TRUE)\n# ->\ndf %>% mutate(across(is.numeric, mean, na.rm = TRUE))\n\n### из _at в accross\ndf %>% mutate_at(vars(c(x, starts_with(\"y\"))), mean, na.rm = TRUE)\n# ->\ndf %>% mutate(across(c(x, starts_with(\"y\")), mean, na.rm = TRUE))\n\n### из _all в accroos\ndf %>% mutate_all(mean, na.rm = TRUE)\n# ->\ndf %>% mutate(across(everything(), mean, na.rm = TRUE))"},{"path":"функция-across.html","id":"упраженения","chapter":"Урок 2 Функция across()","heading":"2.4 Упраженения","text":"Как и в предыдущем уроке выполнять упражнения необходимо на таблице iris.Используйте функцию across(), и разделите значения полей имена которых заканчиваются на Length на среднее значение по этим же столбцам.Посчитайте среднее значение столбцов, имена которых начинаются на Sepal сгруппировав данные по столбцу Species.","code":""},{"path":"перебор-строк-функцией-rowwise.html","id":"перебор-строк-функцией-rowwise","chapter":"Урок 3 Перебор строк функцией rowwise()","heading":"Урок 3 Перебор строк функцией rowwise()","text":"","code":""},{"path":"перебор-строк-функцией-rowwise.html","id":"описание-2","chapter":"Урок 3 Перебор строк функцией rowwise()","heading":"3.1 Описание","text":"В этом видео мы разберёмся с функцией rowwise(), из пакета dplyr.Данная функция позволяет вам осуществить перебор строк таблицы не прибегая к циклам и функциям семейства apply или им подобным.В основе урока лежит статья “dplyr 1.0.0: working within rows”.","code":""},{"path":"перебор-строк-функцией-rowwise.html","id":"видео-2","chapter":"Урок 3 Перебор строк функцией rowwise()","heading":"3.2 Видео","text":"","code":""},{"path":"перебор-строк-функцией-rowwise.html","id":"код-2","chapter":"Урок 3 Перебор строк функцией rowwise()","heading":"3.3 Код","text":"","code":"\n#devtools::install_github(\"tidyverse/dplyr\")\nlibrary(dplyr)\n\n# test data\ndf <- tibble(\n  student_id = 1:4, \n  test1 = 10:13, \n  test2 = 20:23, \n  test3 = 30:33, \n  test4 = 40:43\n)\n\ndf\n\n# попытка посчитать среднюю оценку по студету\ndf %>% mutate(avg = mean(c(test1, test2, test3, test4)))\n\n# используем rowwise для преобразования фрейма\nrf <- rowwise(df, student_id)\nrf\n\nrf %>% mutate(avg = mean(c(test1, test2, test3, test4)))\n\n# тоже самое с использованием c_across\nrf %>% mutate(avg = mean(c_across(starts_with(\"test\"))))\n\n# ###########################\n# некоторые арифметические операции векторизированы по умолчанию\ndf %>% mutate(total = test1 + test2 + test3 + test4)\n\n# этот подход можно использовать для вычисления среднего\ndf %>% mutate(avg = (test1 + test2 + test3 + test4) / 4)\n\n# так же вы можете использовать некоторые специальные функции\n# для вычисления некоторых статистик\ndf %>% mutate(\n  min = pmin(test1, test2, test3, test4), \n  max = pmax(test1, test2, test3, test4), \n  string = paste(test1, test2, test3, test4, sep = \"-\")\n)\n# все векторизированные функции будут работать быстрее чем rowwise\n# но rowwise позволяет векторизировать любую функцию\n\n# ##################################\n# работа со столбцами списками\ndf <- tibble(\n  x = list(1, 2:3, 4:6),\n  y = list(TRUE, 1, \"a\"),\n  z = list(sum, mean, sd)\n)\n\n# мы можем перебором обработать каждый список\ndf %>% \n  rowwise() %>% \n  summarise(\n    x_length = length(x),\n    y_type = typeof(y),\n    z_call = z(1:5)\n  )\n\n# ##################################\n# симуляция случайных данных\ndf <- tribble(\n  ~id, ~ n, ~ min, ~ max,\n  1,   3,     0,     1,\n  2,   2,    10,   100,\n  3,   2,   100,  1000,\n)\n\n# используем rowwise для симуляции данных\ndf %>%\n  rowwise(id) %>%\n  mutate(data = list(runif(n, min, max)))\n\ndf %>%\n  rowwise(id) %>%\n  summarise(x = runif(n, min, max))\n\n# ##################################\n# функция nest_by позволяет создавать столбцы списки\nby_cyl <- mtcars %>% nest_by(cyl)\nby_cyl\n\n# такой подход удобно использовать при построении линейной модели\n# используем mutate для подгонки моели под каждую группа данных\nby_cyl <- by_cyl %>% mutate(model = list(lm(mpg ~ wt, data = data)))\nby_cyl\n# теперь с помощью summarise \n# можно извлекать сводки или коэфициенты построенной модели\nby_cyl %>% summarise(broom::glance(model))\nby_cyl %>% summarise(broom::tidy(model))"},{"path":"обновлённая-функция-summarise.html","id":"обновлённая-функция-summarise","chapter":"Урок 4 Обновлённая функция summarise()","heading":"Урок 4 Обновлённая функция summarise()","text":"","code":""},{"path":"обновлённая-функция-summarise.html","id":"описание-3","chapter":"Урок 4 Обновлённая функция summarise()","heading":"4.1 Описание","text":"В этом уроке мы рассмотрим новые возможности функции summarise().Урок основан на статье “dplyr 1.0.0: new summarise() features”.","code":""},{"path":"обновлённая-функция-summarise.html","id":"видео-3","chapter":"Урок 4 Обновлённая функция summarise()","heading":"4.2 Видео","text":"","code":""},{"path":"обновлённая-функция-summarise.html","id":"код-3","chapter":"Урок 4 Обновлённая функция summarise()","heading":"4.3 Код","text":"","code":"\n#devtools::install_github(\"tidyverse/dplyr\")\nlibrary(dplyr)\n\n# Основные изменения\n## теперь sunnarise может вернуть\n### вектор любой длинны\n### дата фрейм любой размерности\n\n# #######################################################\n# тестовые данные\n# #######################################################\ndf <- tibble(\n  grp = rep(1:2, each = 5), \n  x = c(rnorm(5, -0.25, 1), rnorm(5, 0, 1.5)),\n  y = c(rnorm(5, 0.25, 1), rnorm(5, 0, 0.5)),\n)\n\ndf\n\n# получим минимальные и максимальные значения для каждой группы\n# и поместим эти значения в строки\ndf %>% \n  group_by(grp) %>% \n  summarise(rng = range(x))\n\n## функция range возвращает вектор длинны 2\nrange(df$x)\n## но функция summarise разворачивает его, \n## приводя каждое из возвращаемых значений в новую строку\n\n# тоже самое, но для столбцов\ndf %>% \n  group_by(grp) %>% \n  summarise(tibble(min = min(x), mean = mean(x)))\n\n# #######################################################\n# Расчёт квантилей\n# #######################################################\ndf %>% \n  group_by(grp) %>% \n  summarise(x = quantile(x, c(0.25, 0.5, 0.75)), q = c(0.25, 0.5, 0.75))\n\n# можем избежать дублирования кода и написать функцию для вычисления квантиля\nquibble <- function(x, q = c(0.25, 0.5, 0.75)) {\n  tibble(x = quantile(x, q), q = q)\n}\n# используем собственную функцию в summarise\ndf %>% \n  group_by(grp) %>% \n  summarise(quibble(x, c(0.25, 0.5, 0.75)))\n\n# доработаем функцию таким образом \n# что бы названия столбца подтягивались из аргумена\nquibble2 <- function(x, q = c(0.25, 0.5, 0.75)) {\n  tibble(\"{{ x }}\" := quantile(x, q), \"{{ x }}_q\" := q)\n}\n\ndf %>% \n  group_by(grp) %>% \n  summarise(quibble2(x, c(0.25, 0.5, 0.75)))\n\n\n# мы не присваивали имена новых столбцов внутри summarise\n# потому что если функция возвращает объект сложной стурктуры\n# мы получим вложенные дата фреймы\nout <- df %>% \n  group_by(grp) %>% \n  summarise(quantile = quibble2(y, c(0.25, 0.75)))\n\nstr(out)\n\n# обращаемся к вложенному фрейму\nout$y\n\n# или к его столбцам\n# по смыслу такая конструкция напоминает объяденённые имена стобцов в электронных таблицах\nout$quantile$y_q\n\n# summarise + rowwise\n# эта комбинация функций теперь может заменить purrr и apply\ntibble(path = dir(pattern = \"\\\\.csv$\")) %>% \n  rowwise(path) %>% \n  summarise(readr::read_csv(path))\n\n# #######################################################\n# Предыдущие подходы\n# #######################################################\n# вычисляем квантили\ndf %>% \n  group_by(grp) %>% \n  summarise(y = list(quibble(y, c(0.25, 0.75)))) %>% \n  tidyr::unnest(y)\n\ndf %>% \n  group_by(grp) %>% \n  do(quibble(.$y, c(0.25, 0.75)))"},{"path":"добавление-изменение-и-удаление-строк-дата-фрейма-через-rows_.html","id":"добавление-изменение-и-удаление-строк-дата-фрейма-через-rows_","chapter":"Урок 5 Добавление, изменение и удаление строк дата фрейма через rows_*()","heading":"Урок 5 Добавление, изменение и удаление строк дата фрейма через rows_*()","text":"","code":""},{"path":"добавление-изменение-и-удаление-строк-дата-фрейма-через-rows_.html","id":"описание-4","chapter":"Урок 5 Добавление, изменение и удаление строк дата фрейма через rows_*()","heading":"5.1 Описание","text":"В SQL мы часто используем операции изменения данных, такие как INSERT, UPDATE и DELETE, так вот начиная с версии dplyr 1.0.0 в пакете появилось целое семейство функций которые реализуют эти операции с фреймами на языке R.Функции которые будут рассмотрены в этом видео:\n- rows_insert()\n- rows_update()\n- rows_upsert()\n- rows_patch()\n- rows_delete()Также мы разберёмся с новым аргументом функции summarise(), .groups, который позволяет изменять группировку данных после их агрегации.В основе урока лежит статья “dplyr 1.0.0: last minute additions”.","code":""},{"path":"добавление-изменение-и-удаление-строк-дата-фрейма-через-rows_.html","id":"видео-4","chapter":"Урок 5 Добавление, изменение и удаление строк дата фрейма через rows_*()","heading":"5.2 Видео","text":"","code":""},{"path":"добавление-изменение-и-удаление-строк-дата-фрейма-через-rows_.html","id":"код-4","chapter":"Урок 5 Добавление, изменение и удаление строк дата фрейма через rows_*()","heading":"5.3 Код","text":"","code":"\n#devtools::install_github(\"tidyverse/dplyr\")\nlibrary(dplyr)\n\n# summarise + .groups\nstarwars %>% \n  group_by(homeworld, species) %>% \n  summarise(n = n())\n\n## аргумент .groups\n### .groups = \"drop_last\" удалит последнюю группу\n### .groups = \"drop\" удалит всю группировку\n### .groups = \"keep\" созранит всю группировку\n### .groups = \"rowwise\" разобъёт фрейм на группы как rowwise()\n\n# rows_*()\n## rows_update(x, y) обновляет строки в таблице x найденные в таблице y\n## rows_patch(x, y) работает аналогично rows_update() но заменяет только NA\n## rows_insert(x, y) добавляет строки в таблицу x из таблицы y\n## rows_upsert(x, y) обновляет найденные строки в x и добавляет не найденные из таблицы y\n## rows_delete(x, y) удаляет строки из x найденные в таблице y.\n\n# Создаём тестовые данные\ndf <- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2)\ndf\n\nnew <- tibble(a = c(4, 5), b = c(\"d\", \"e\"), c = c(3.5, 4.5))\nnew\n\n# БАзовые примеры\n## добавляем новые строки\ndf %>% rows_insert(new)\n\n## row_insert вернёт ошибку если мы попытаемся добавить уже существующую строку\ndf %>% rows_insert(tibble(a = 3, b = \"c\"))\n\n## если вы хотите обновить существующее значение необходимо использовать row_update\ndf %>% rows_update(tibble(a = 3, b = \"c\"))\n\n## но rows_update вернёт ошибку если вы попытаетесь обновить несуществующее значание\ndf %>% rows_update(tibble(a = 4, b = \"d\"))\n\n## rows_patch заполнит только пропущенные значения по ключу\ndf %>% \n  rows_patch(tibble(a = 2:3, b = \"B\"))\n\n## rows_upsert также вы можете добавлять новые и заменять существуюие значения \n## функцией rows_upsert\ndf %>% \n  rows_upsert(tibble(a = 3, b = \"c\")) %>% \n  rows_upsert(tibble(a = 4, b = \"d\"))\n\n# ################################\n# РАЗБЕРЁМ Аргументы немного более подробно\nset.seed(555)\n\n# менеджеры\nmanagers <- c(\"Paul\", \"Alex\", \"Tim\", \"Bill\", \"John\")\n# товары\nproducts <- tibble(name  = paste0(\"product_\", LETTERS), \n                   price = round(runif(n = length(LETTERS), 100, 400), 0))\n\n# функция генерации купленных товаров\nprod_list <- function(prod_list, size_min, size_max) {\n  \n  prod <- tibble(product = sample(prod_list, \n                                  size = round(runif(1, size_min, size_max), 0) ,\n                                  replace = F))\n    return(prod)\n}\n\n\n# генерируем продажи\nsales <- tibble(id         = 1:200,\n                manager_id = sample(managers, size = 200, replace = T),\n                refund     = FALSE,\n                refund_sum = 0)\n\n# генерируем списки купленных товаров\nsale_proucts <-\n    sales %>%\n      rowwise(id) %>%\n      summarise(prod_list(products$name, 1, 6)) %>%\n      left_join(products, by = c(\"product\" = \"name\"))\n  \n# объединяем продажи с товарами\nsales <- left_join(sales, sale_proucts, by = \"id\")\n\n# возвраты\nrefund <- sample_n(sales, 25) %>%\n          mutate( refund = TRUE,\n                  refund_sum = price * 0.9) %>%\n          select(-price, -manager_id) \n\n# отмечаем возвраты в таблице продаж\nsales %>%\n  rows_update(refund)\n\n# аргумент by\nresult <-\n  sales %>%\n    rows_update(refund, by = c(\"id\", \"product\"))"},{"path":"решения-заданий.html","id":"решения-заданий","chapter":"Решения заданий","heading":"Решения заданий","text":"","code":""},{"path":"решения-заданий.html","id":"задания-к-первому-уроку","chapter":"Решения заданий","heading":"Задания к первому уроку","text":"Выберите все столбцы, которые заканчиваются на Width.Переместите с помощью функции relocate() единственный текстовый столбец в левую часть таблицы.Замените с помощью функции rename_with() в названии столбцов точку на нижнее подчёркивание, и преобразуйте имена в нижний регистр.","code":"\nlibrary(dplyr)\n#> \n#> Присоединяю пакет: 'dplyr'\n#> Следующие объекты скрыты от 'package:stats':\n#> \n#>     filter, lag\n#> Следующие объекты скрыты от 'package:base':\n#> \n#>     intersect, setdiff, setequal, union\n\nselect(iris, ends_with('Width')) %>% \n  tibble()\n#> # A tibble: 150 x 2\n#>    Sepal.Width Petal.Width\n#>          <dbl>       <dbl>\n#>  1         3.5         0.2\n#>  2         3           0.2\n#>  3         3.2         0.2\n#>  4         3.1         0.2\n#>  5         3.6         0.2\n#>  6         3.9         0.4\n#>  7         3.4         0.3\n#>  8         3.4         0.2\n#>  9         2.9         0.2\n#> 10         3.1         0.1\n#> # ... with 140 more rows\nrelocate(iris, where(is.factor)) %>% \n  tibble()\n#> # A tibble: 150 x 5\n#>    Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n#>    <fct>          <dbl>       <dbl>        <dbl>       <dbl>\n#>  1 setosa           5.1         3.5          1.4         0.2\n#>  2 setosa           4.9         3            1.4         0.2\n#>  3 setosa           4.7         3.2          1.3         0.2\n#>  4 setosa           4.6         3.1          1.5         0.2\n#>  5 setosa           5           3.6          1.4         0.2\n#>  6 setosa           5.4         3.9          1.7         0.4\n#>  7 setosa           4.6         3.4          1.4         0.3\n#>  8 setosa           5           3.4          1.5         0.2\n#>  9 setosa           4.4         2.9          1.4         0.2\n#> 10 setosa           4.9         3.1          1.5         0.1\n#> # ... with 140 more rows\nrenamer <- function(x) gsub('\\\\.', '\\\\_', x) %>% tolower()\nrename_with(iris, renamer) %>% \n  tibble()\n#> # A tibble: 150 x 5\n#>    sepal_length sepal_width petal_length petal_width species\n#>           <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n#>  1          5.1         3.5          1.4         0.2 setosa \n#>  2          4.9         3            1.4         0.2 setosa \n#>  3          4.7         3.2          1.3         0.2 setosa \n#>  4          4.6         3.1          1.5         0.2 setosa \n#>  5          5           3.6          1.4         0.2 setosa \n#>  6          5.4         3.9          1.7         0.4 setosa \n#>  7          4.6         3.4          1.4         0.3 setosa \n#>  8          5           3.4          1.5         0.2 setosa \n#>  9          4.4         2.9          1.4         0.2 setosa \n#> 10          4.9         3.1          1.5         0.1 setosa \n#> # ... with 140 more rows"},{"path":"решения-заданий.html","id":"задания-ко-второму-уроку","chapter":"Решения заданий","heading":"Задания ко второму уроку","text":"Используйте функцию across(), и разделите значения полей имена которых заканчиваются на Length на среднее значение по этим же столбцам.Посчитайте среднее значение столбцов, имена которых начинаются на Sepal сгруппировав данные по столбцу Species.","code":"\nlibrary(dplyr)\n\nmutate(iris, across(ends_with('Length'), ~ . / mean(.))) %>% \n  tibble()\n#> # A tibble: 150 x 5\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#>           <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n#>  1        0.873         3.5        0.373         0.2 setosa \n#>  2        0.839         3          0.373         0.2 setosa \n#>  3        0.804         3.2        0.346         0.2 setosa \n#>  4        0.787         3.1        0.399         0.2 setosa \n#>  5        0.856         3.6        0.373         0.2 setosa \n#>  6        0.924         3.9        0.452         0.4 setosa \n#>  7        0.787         3.4        0.373         0.3 setosa \n#>  8        0.856         3.4        0.399         0.2 setosa \n#>  9        0.753         2.9        0.373         0.2 setosa \n#> 10        0.839         3.1        0.399         0.1 setosa \n#> # ... with 140 more rows\ngroup_by(iris, Species) %>% \n  summarise(across(starts_with('Sepal'), mean))\n#> # A tibble: 3 x 3\n#>   Species    Sepal.Length Sepal.Width\n#>   <fct>             <dbl>       <dbl>\n#> 1 setosa             5.01        3.43\n#> 2 versicolor         5.94        2.77\n#> 3 virginica          6.59        2.97"},{"path":"заключение.html","id":"заключение","chapter":"Заключение","heading":"Заключение","text":"Надеюсь данный мини курс по введению в dplyr 1.0.0 был вам полезен, данный релиз созержал действительно много полезных доработок и новых функций.Буду рад видеть вас среди подписчиков моего Telegram и YouTube канала.Алексей Селезнёв","code":""}]
