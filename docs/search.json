[{"path":"index.html","id":"введение","chapter":"Введение","heading":"Введение","text":"","code":""},{"path":"index.html","id":"о-курсе","chapter":"Введение","heading":"О курсе","text":"dplyr - один из наиболее популярных пакетов, который реализует грамматику манипуляции данными в языке R. Официально первый релиз dplyr был выпещен в 2014 году, но пакет развивался, и первая стабильная версия с устоявшимся синтаксисом, под номером 1.0.0 была выпущена весной 2020 года. Этому релизу предшествовала серия статей, в которых Хедли Викхем описывал все нововведения в dplyr. Этот мини курс появился из 5 видео уроков снятых по этим статьям.В основе видео уроков лежат следующие статьи:dplyr 1.0.0: select, rename, relocatedplyr 1.0.0: working across columnsdplyr 1.0.0: working within rowsdplyr 1.0.0: new summarise() featuresdplyr 1.0.0: last minute additions","code":""},{"path":"index.html","id":"для-кого-этот-курс","chapter":"Введение","heading":"Для кого этот курс","text":"Для прохождения курса вы уже должны иметь навыки работы с инфраструктурой tidyverse. Приступать к прохождению курса “Введение в dplyr 1.0.0” я советую тем, кто уже имеет базовые навыки работы в R. Т.е. изначально я рекомендую вам пройти курс “Язык R для пользователей Excel”, и потом приступать к прохождению данного курса.","code":""},{"path":"index.html","id":"рекомендации-по-прохождению-курса","chapter":"Введение","heading":"Рекомендации по прохождению курса","text":"Данный курс состоит из 5 видео уроков общей длительность 1 час 2 минуты. К каждому уроку есть рассмотренный в видео код, это сделано для вашего удобства, скопируйте его и выполняйте по мере просмотра видео лекции.К каждому уроке есть упражнения, их выполнение не является обязательным, но поможет вам понять усвоили ли вы материал урока. Все упражнения достаточно простые, и зачастую не заберут у вас более 5 - 10 минут. Решение каждого упражнения можно найти в разделе “Решение заданий”.","code":""},{"path":"index.html","id":"об-авторе","chapter":"Введение","heading":"Об авторе","text":"Меня зовут Алексей Селезнёв, с 2008 года я являюсь практикующим аналитиком. На данный момент основной моей деятельностью является развитие отдела аналитики в агентстве интернет-маркетинга Netpeak.\nМною были разработаны такие R пакеты как: ryandexdirect, rfacebookstat, timeperiodsR, rvkstat и некоторые другие. На данный момент написанные мной пакеты только с CRAN были установленны более 130 000 раз.Также я являюсь автором курса “Язык R для интернет-маркетинга”.Веду свой авторский Telegram и YouTube канал R4marketing. Буду рад видеть вас в рядах подписчиков.Периодически публикую статью на различных интернет медиа, зачастую это Хабр и Netpeak Journal.Неоднократно выступал на профильных конференциях по аналитике и интернет маркетингу, среди которых Матемаркетинг, GoAnalytics, Analyze, eCommerce, 8P и прочие.Начиная с 2016 года всячески стараюсь популяризировать язык R среди русскоязычных аналитиков и маркетологов. Этот курс также был создан с этой целью.","code":""},{"path":"index.html","id":"программа-курса","chapter":"Введение","heading":"Программа курса","text":"Функции select(), rename_with() и relocate()Функция across()Перебор строк функцией rowwise()Обновлённая функция summarise()Добавление, изменение и удаление строк дата фрейма через rows_*()","code":""},{"path":"index.html","id":"благодарности","chapter":"Введение","heading":"Благодарности","text":"Курс, и все сопутствующие материалы предоставляются бесплатно, но если у вас есть желание отблагодарить автора за этот видео курс вы можете перечислить любую произвольную сумму на этой странице.","code":""},{"path":"функции-select-rename_with-и-relocate.html","id":"функции-select-rename_with-и-relocate","chapter":"Урок 1 Функции select(), rename_with() и relocate()","heading":"Урок 1 Функции select(), rename_with() и relocate()","text":"","code":""},{"path":"функции-select-rename_with-и-relocate.html","id":"описание","chapter":"Урок 1 Функции select(), rename_with() и relocate()","heading":"1.1 Описание","text":"Первый урок курса посвящён таким операциям, как продвинутый выбор столбцов, их переименование и изменения порядка столбцов таблицы.В этом видео уроке мы познакомимся с такими функциями как: select(), rename_with(), relocate(), any_of(), all_of().В основе урока лежит статья “dplyr 1.0.0: select, rename, relocate”.","code":""},{"path":"функции-select-rename_with-и-relocate.html","id":"видео","chapter":"Урок 1 Функции select(), rename_with() и relocate()","heading":"1.2 Видео","text":"","code":""},{"path":"функции-select-rename_with-и-relocate.html","id":"код","chapter":"Урок 1 Функции select(), rename_with() и relocate()","heading":"1.3 Код","text":"","code":"\n#devtools::install_github(\"tidyverse/dplyr\")\nlibrary(dplyr, warn.conflicts = FALSE)\n\n# rename\n# Переименовать столбцы для устранение дублирования их имён\ndf1 <- tibble(a = 1:5, a = 5:1, .name_repair = \"minimal\")\ndf1\n\ndf1 %>% rename(b = 2)\n\n# select\n# обращение к столбцам по типу\ndf2 <- tibble(x1 = 1, x2 = \"a\", x3 = 2, y1 = \"b\", y2 = 3, y3 = \"c\", y4 = 4)\n\n# числовые столбцы\ndf2 %>% select(is.numeric)\n# НЕ текстовые столбцы\ndf2 %>% select(!is.character)\n\n# смешанный тип обращения\n# числовые стобцы, название которых начинается на X\ndf2 %>% select(starts_with(\"x\") & is.numeric)\n\n\n# выбор полей с помощью функций any_of и all_of\nvars <- c(\"x1\", \"x2\", \"y1\", \"z\")\ndf2 %>% select(any_of(vars))\n\ndf2 %>% select(all_of(vars))\n\n\n# функция rename_with\ndf2 %>% rename_with(toupper)\n\ndf2 %>% rename_with(toupper, starts_with(\"x\"))\n\ndf2 %>% rename_with(toupper, is.numeric)\n\n\n# relocate для изменения порядка стобцов\ndf3 <- tibble(w = 0, x = 1, y = \"a\", z = \"b\")\n# переместить столбцы y, z в начало\ndf3 %>% relocate(y, z)\n# переместить текстовые столбцы вначало\ndf3 %>% relocate(is.character)\n\n# поместить столбец w после y\ndf3 %>% relocate(w, .after = y)\n# поместить столбец w перед y\ndf3 %>% relocate(w, .before = y)\n# переместить w в конец\ndf3 %>% relocate(w, .after = last_col())"},{"path":"функции-select-rename_with-и-relocate.html","id":"упражнения","chapter":"Урок 1 Функции select(), rename_with() и relocate()","heading":"1.4 Упражнения","text":"Для примера мы будем использовать встроенный набор данных iris, выполните следующие действия:Выберите все столбцы, которые заканчиваются на Width.Переместите с помощью функции relocate() единственный текстовый столбец в левую часть таблицы.Замените с помощью функции rename_with() в названии столбцов точку на нижнее подчёркивание, и преобразуйте имена в нижний регистр.","code":""},{"path":"функция-across.html","id":"функция-across","chapter":"Урок 2 Функция across()","heading":"Урок 2 Функция across()","text":"","code":""},{"path":"функция-across.html","id":"описание-1","chapter":"Урок 2 Функция across()","heading":"2.1 Описание","text":"В этом уроке продемонстрирована работа с новой функцией across(), которая упрощает обращение к столбцам внутри таких функций как mutate() и summarise(). По сути функция across() заменяет функции с приставками *_at() , *_if(), *_all().Обзор основан на статье Хедли Викхема “dplyr 1.0.0: working across columns”.","code":""},{"path":"функция-across.html","id":"видео-1","chapter":"Урок 2 Функция across()","heading":"2.2 Видео","text":"","code":""},{"path":"функция-across.html","id":"код-1","chapter":"Урок 2 Функция across()","heading":"2.3 Код","text":"","code":"\n# devtools::install_github(\"tidyverse/dplyr\")\nlibrary(dplyr, warn.conflicts = FALSE)\n\n# тестовый дата фрейм\ndf <- tibble(g1 = as.factor(sample(letters[1:4],size = 10, replace = T )),\n             g2 = as.factor(sample(LETTERS[1:3],size = 10, replace = T )),\n             a  = runif(10, 1, 10),\n             b  = runif(10, 10, 20),\n             c  = runif(10, 15, 30),\n             d  = runif(10, 1, 50))\n\n# о чём пойдёт речь\n## копирование кода, когда требуется \n## произвести одну и туже операцию с разными функциями\ndf %>% \n  group_by(g1, g2) %>% \n  summarise(a = mean(a), b = mean(b), c = mean(c), d = mean(c))\n\n# новый способ\n## теперь для таких преобразований можно\n## использовать тот же синтаксис что и в select()\n### посчитать среднее по столбцам от a до d\ndf %>% \n  group_by(g1, g2) %>% \n  summarise(across(a:d, mean))\n\n### или посчитать среднее выбрав все числовые столбцы \ndf %>% \n  group_by(g1, g2) %>% \n  summarise(across(is.numeric, mean))\n\n# ##############################\n# Простой пример\n# аргументы функции accros\n\n## .cols - выбор столбцов по позиции, имени, функцией, типу данных, или комбинируя любые перечисленные способы\n## .fns - функция, или список функций которые необходимо применить к каждому столбцу\n\n## считаем количество униклаьных значений в текстовых полях\nstarwars %>% \n  summarise(across(is.character, n_distinct))\n\n## пример с фильтрацией данных\nstarwars %>% \n  group_by(species) %>% \n  filter(n() > 1) %>% \n  summarise(across(c(sex, gender, homeworld), n_distinct))\n\n## комбинируем accross с другими вычислениями\nstarwars %>% \n  group_by(homeworld) %>% \n  filter(n() > 1) %>% \n  summarise(across(is.numeric, mean, na.rm = TRUE), \n            n = n())\n\n# ##############################\n# Чем accross лучше предыдущих функций с суфиксами _at, _if, _all\n\n## 1. accross позволяет комбинировать различные вычисления внутри одной summarise \n## пример из статьи\ndf %>%\n  group_by(g1, g2) %>% \n  summarise(\n    across(is.numeric, mean), \n    across(is.factor, nlevels),\n    n = n(), \n  )\n\n## рабочий пример\nstarwars %>% \n  group_by(species) %>% \n  summarise(across(is.character, n_distinct), \n            across(is.numeric, mean), \n            across(is.list, length), \n            n = n()\n  )\n\n## 2. уменьшает количество необходимых функций в dplyr, что облегчает их запоминание\n## 3. объединяет возможности функций с суфиксами if_, at_, и даёт возможность объединять их возможности\n## 4. accross не требует от вас использования функции vars для указания нужных столбцлв, как это было раньше\n\n# ##############################\n# перевод старого кода на accross\n\n## для перевода функций с суфиксами _at, _if, _all используйте следующие правила\n### в accross первым агрументом будет:\n### Для *_if() старый второй аргумент.\n### Для *_at() старый второй аргумент с удаленным вызовом vars().\n### Для *_all(), в качестве первого аргумента передайте функцию everything()\n\n## примеры\ndf <- tibble(y_a  = runif(10, 1, 10),\n             y_b  = runif(10, 10, 20),\n             x    = runif(10, 15, 30),\n             d    = runif(10, 1, 50))\n\n### из _if в accross\ndf %>% mutate_if(is.numeric, mean, na.rm = TRUE)\n# ->\ndf %>% mutate(across(is.numeric, mean, na.rm = TRUE))\n\n### из _at в accross\ndf %>% mutate_at(vars(c(x, starts_with(\"y\"))), mean, na.rm = TRUE)\n# ->\ndf %>% mutate(across(c(x, starts_with(\"y\")), mean, na.rm = TRUE))\n\n### из _all в accroos\ndf %>% mutate_all(mean, na.rm = TRUE)\n# ->\ndf %>% mutate(across(everything(), mean, na.rm = TRUE))"},{"path":"функция-across.html","id":"упраженения","chapter":"Урок 2 Функция across()","heading":"2.4 Упраженения","text":"Как и в предыдущем уроке выполнять упражнения необходимо на таблице iris.Используйте функцию across(), и разделите значения полей имена которых заканчиваются на Length на среднее значение по этим же столбцам.Посчитайте среднее значение столбцов, имена которых начинаются на Sepal сгруппировав данные по столбцу Species.","code":""},{"path":"перебор-строк-функцией-rowwise.html","id":"перебор-строк-функцией-rowwise","chapter":"Урок 3 Перебор строк функцией rowwise()","heading":"Урок 3 Перебор строк функцией rowwise()","text":"","code":""},{"path":"перебор-строк-функцией-rowwise.html","id":"описание-2","chapter":"Урок 3 Перебор строк функцией rowwise()","heading":"3.1 Описание","text":"В этом видео мы разберёмся с функцией rowwise(), из пакета dplyr.Данная функция позволяет вам осуществить перебор строк таблицы не прибегая к циклам и функциям семейства apply или им подобным.В основе урока лежит статья “dplyr 1.0.0: working within rows”.","code":""},{"path":"перебор-строк-функцией-rowwise.html","id":"видео-2","chapter":"Урок 3 Перебор строк функцией rowwise()","heading":"3.2 Видео","text":"","code":""},{"path":"перебор-строк-функцией-rowwise.html","id":"код-2","chapter":"Урок 3 Перебор строк функцией rowwise()","heading":"3.3 Код","text":"","code":"\n#devtools::install_github(\"tidyverse/dplyr\")\nlibrary(dplyr)\n\n# test data\ndf <- tibble(\n  student_id = 1:4, \n  test1 = 10:13, \n  test2 = 20:23, \n  test3 = 30:33, \n  test4 = 40:43\n)\n\ndf\n\n# попытка посчитать среднюю оценку по студету\ndf %>% mutate(avg = mean(c(test1, test2, test3, test4)))\n\n# используем rowwise для преобразования фрейма\nrf <- rowwise(df, student_id)\nrf\n\nrf %>% mutate(avg = mean(c(test1, test2, test3, test4)))\n\n# тоже самое с использованием c_across\nrf %>% mutate(avg = mean(c_across(starts_with(\"test\"))))\n\n# ###########################\n# некоторые арифметические операции векторизированы по умолчанию\ndf %>% mutate(total = test1 + test2 + test3 + test4)\n\n# этот подход можно использовать для вычисления среднего\ndf %>% mutate(avg = (test1 + test2 + test3 + test4) / 4)\n\n# так же вы можете использовать некоторые специальные функции\n# для вычисления некоторых статистик\ndf %>% mutate(\n  min = pmin(test1, test2, test3, test4), \n  max = pmax(test1, test2, test3, test4), \n  string = paste(test1, test2, test3, test4, sep = \"-\")\n)\n# все векторизированные функции будут работать быстрее чем rowwise\n# но rowwise позволяет векторизировать любую функцию\n\n# ##################################\n# работа со столбцами списками\ndf <- tibble(\n  x = list(1, 2:3, 4:6),\n  y = list(TRUE, 1, \"a\"),\n  z = list(sum, mean, sd)\n)\n\n# мы можем перебором обработать каждый список\ndf %>% \n  rowwise() %>% \n  summarise(\n    x_length = length(x),\n    y_type = typeof(y),\n    z_call = z(1:5)\n  )\n\n# ##################################\n# симуляция случайных данных\ndf <- tribble(\n  ~id, ~ n, ~ min, ~ max,\n  1,   3,     0,     1,\n  2,   2,    10,   100,\n  3,   2,   100,  1000,\n)\n\n# используем rowwise для симуляции данных\ndf %>%\n  rowwise(id) %>%\n  mutate(data = list(runif(n, min, max)))\n\ndf %>%\n  rowwise(id) %>%\n  summarise(x = runif(n, min, max))\n\n# ##################################\n# функция nest_by позволяет создавать столбцы списки\nby_cyl <- mtcars %>% nest_by(cyl)\nby_cyl\n\n# такой подход удобно использовать при построении линейной модели\n# используем mutate для подгонки моели под каждую группа данных\nby_cyl <- by_cyl %>% mutate(model = list(lm(mpg ~ wt, data = data)))\nby_cyl\n# теперь с помощью summarise \n# можно извлекать сводки или коэфициенты построенной модели\nby_cyl %>% summarise(broom::glance(model))\nby_cyl %>% summarise(broom::tidy(model))"},{"path":"перебор-строк-функцией-rowwise.html","id":"упражнения-1","chapter":"Урок 3 Перебор строк функцией rowwise()","heading":"3.4 Упражнения","text":"В этот раз тестовые данные для выполнения упражнения мы будем генерировать самостоятельно, используйте приведённый ниже код.В результате вы получили продаж, каждая строка которой хранит данные за определённый год, а каждый столбец за определённый месяц года.Ваша задача не переворачивая таблицу, добавить в неё 4 столбца:winter_avg_sales - средний объём продаж за зимные месяца;spring_avg_sales - средний объём продаж за весенние месяца;summer_avg_sales - средний объём продаж за летние месяца;autumn_avg_sales - средний объём продаж за осенние месяца;И оставить из исходной таблицы только столбец с обозначением года, и рассчитанные на предыдущем шаге столбцы.Результат вычислений будет выглядить вот так:","code":"\n# тестовый набор данных\nset.seed(400)\nyear <- 2000:2005\nsales <- sapply(\n  month.abb, \n  FUN = function(x) round(runif(n = 6, min = 100, max = 400), 0)\n  )\n\nsales <- as.data.frame(sales, row.names = year)\nsales$year <- year\nsales\n#>      Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec year\n#> 2000 145 174 342 185 117 313 314 102 382 220 226 297 2000\n#> 2001 156 251 286 280 179 176 317 323 247 194 233 263 2001\n#> 2002 319 182 329 155 240 177 146 244 370 300 197 187 2002\n#> 2003 209 187 238 296 393 234 366 314 198 213 206 234 2003\n#> 2004 379 126 263 261 136 201 352 351 362 203 304 183 2004\n#> 2005 221 275 374 318 127 376 257 193 340 190 225 273 2005# A tibble: 6 x 5\n# Rowwise: \n   year winter_avg_sales spring_avg_sales summer_avg_sales autumn_avg_sales\n  <int>            <dbl>            <dbl>            <dbl>            <dbl>\n1  2000              322             226              145              227 \n2  2001              174             192.             179.             295.\n3  2002              106             352.             215.             258.\n4  2003              105             260.             334.             206.\n5  2004              167             192.             239              254.\n6  2005              210             191.             271.             235 "},{"path":"обновлённая-функция-summarise.html","id":"обновлённая-функция-summarise","chapter":"Урок 4 Обновлённая функция summarise()","heading":"Урок 4 Обновлённая функция summarise()","text":"","code":""},{"path":"обновлённая-функция-summarise.html","id":"описание-3","chapter":"Урок 4 Обновлённая функция summarise()","heading":"4.1 Описание","text":"В этом уроке мы рассмотрим новые возможности функции summarise().Урок основан на статье “dplyr 1.0.0: new summarise() features”.","code":""},{"path":"обновлённая-функция-summarise.html","id":"видео-3","chapter":"Урок 4 Обновлённая функция summarise()","heading":"4.2 Видео","text":"","code":""},{"path":"обновлённая-функция-summarise.html","id":"код-3","chapter":"Урок 4 Обновлённая функция summarise()","heading":"4.3 Код","text":"","code":"\n#devtools::install_github(\"tidyverse/dplyr\")\nlibrary(dplyr)\n\n# Основные изменения\n## теперь sunnarise может вернуть\n### вектор любой длинны\n### дата фрейм любой размерности\n\n# #######################################################\n# тестовые данные\n# #######################################################\ndf <- tibble(\n  grp = rep(1:2, each = 5), \n  x = c(rnorm(5, -0.25, 1), rnorm(5, 0, 1.5)),\n  y = c(rnorm(5, 0.25, 1), rnorm(5, 0, 0.5)),\n)\n\ndf\n\n# получим минимальные и максимальные значения для каждой группы\n# и поместим эти значения в строки\ndf %>% \n  group_by(grp) %>% \n  summarise(rng = range(x))\n\n## функция range возвращает вектор длинны 2\nrange(df$x)\n## но функция summarise разворачивает его, \n## приводя каждое из возвращаемых значений в новую строку\n\n# тоже самое, но для столбцов\ndf %>% \n  group_by(grp) %>% \n  summarise(tibble(min = min(x), mean = mean(x)))\n\n# #######################################################\n# Расчёт квантилей\n# #######################################################\ndf %>% \n  group_by(grp) %>% \n  summarise(x = quantile(x, c(0.25, 0.5, 0.75)), q = c(0.25, 0.5, 0.75))\n\n# можем избежать дублирования кода и написать функцию для вычисления квантиля\nquibble <- function(x, q = c(0.25, 0.5, 0.75)) {\n  tibble(x = quantile(x, q), q = q)\n}\n# используем собственную функцию в summarise\ndf %>% \n  group_by(grp) %>% \n  summarise(quibble(x, c(0.25, 0.5, 0.75)))\n\n# доработаем функцию таким образом \n# что бы названия столбца подтягивались из аргумена\nquibble2 <- function(x, q = c(0.25, 0.5, 0.75)) {\n  tibble(\"{{ x }}\" := quantile(x, q), \"{{ x }}_q\" := q)\n}\n\ndf %>% \n  group_by(grp) %>% \n  summarise(quibble2(x, c(0.25, 0.5, 0.75)))\n\n\n# мы не присваивали имена новых столбцов внутри summarise\n# потому что если функция возвращает объект сложной стурктуры\n# мы получим вложенные дата фреймы\nout <- df %>% \n  group_by(grp) %>% \n  summarise(quantile = quibble2(y, c(0.25, 0.75)))\n\nstr(out)\n\n# обращаемся к вложенному фрейму\nout$y\n\n# или к его столбцам\n# по смыслу такая конструкция напоминает объяденённые имена стобцов в электронных таблицах\nout$quantile$y_q\n\n# summarise + rowwise\n# эта комбинация функций теперь может заменить purrr и apply\ntibble(path = dir(pattern = \"\\\\.csv$\")) %>% \n  rowwise(path) %>% \n  summarise(readr::read_csv(path))\n\n# #######################################################\n# Предыдущие подходы\n# #######################################################\n# вычисляем квантили\ndf %>% \n  group_by(grp) %>% \n  summarise(y = list(quibble(y, c(0.25, 0.75)))) %>% \n  tidyr::unnest(y)\n\ndf %>% \n  group_by(grp) %>% \n  do(quibble(.$y, c(0.25, 0.75)))"},{"path":"обновлённая-функция-summarise.html","id":"упражнение","chapter":"Урок 4 Обновлённая функция summarise()","heading":"4.4 Упражнение","text":"Вам дана таблица параметров генерации случайной выборки с нормальным распределением (генерировать случайную выборку с нормальным распределением позволяет функция rnorm()).Для генерации таблицы параметров выполните следующий код:Теперь сгенерируйте согласно этим параметрам таблицу содержащую в столбце sim номер строки таблицы параметров, а в столбце val сами значения случайных распределений. Для воспроизводимости результатов установите счётчик генерации случайных чисел в позиции 400 (set.seed(400)). Тогда итоговый результат будет иметь следующий вид:","code":"\nlibrary(dplyr)\n\nparams <- tribble(\n ~sim, ~n, ~mean, ~sd,\n    1,  4,     1,   5,\n    2,  7,     2,   10,\n    3,  10,   -1,   25\n)# A tibble: 21 x 2\n# Groups:   sim [3]\n     sim   val\n   <dbl> <dbl>\n 1     1 -1.75\n 2     1 -3.70\n 3     1  2.27\n 4     1 13.2 \n 5     2  9.87\n 6     2 -5.14\n 7     2 -8.09\n 8     2 -3.57\n 9     2  6.77\n10     2 29.4 \n# ... with 11 more rows"},{"path":"добавление-изменение-и-удаление-строк-дата-фрейма-через-rows_.html","id":"добавление-изменение-и-удаление-строк-дата-фрейма-через-rows_","chapter":"Урок 5 Добавление, изменение и удаление строк дата фрейма через rows_*()","heading":"Урок 5 Добавление, изменение и удаление строк дата фрейма через rows_*()","text":"","code":""},{"path":"добавление-изменение-и-удаление-строк-дата-фрейма-через-rows_.html","id":"описание-4","chapter":"Урок 5 Добавление, изменение и удаление строк дата фрейма через rows_*()","heading":"5.1 Описание","text":"В SQL мы часто используем операции изменения данных, такие как INSERT, UPDATE и DELETE, так вот начиная с версии dplyr 1.0.0 в пакете появилось целое семейство функций которые реализуют эти операции с фреймами на языке R.Функции которые будут рассмотрены в этом видео:\n- rows_insert()\n- rows_update()\n- rows_upsert()\n- rows_patch()\n- rows_delete()Также мы разберёмся с новым аргументом функции summarise(), .groups, который позволяет изменять группировку данных после их агрегации.В основе урока лежит статья “dplyr 1.0.0: last minute additions”.","code":""},{"path":"добавление-изменение-и-удаление-строк-дата-фрейма-через-rows_.html","id":"видео-4","chapter":"Урок 5 Добавление, изменение и удаление строк дата фрейма через rows_*()","heading":"5.2 Видео","text":"","code":""},{"path":"добавление-изменение-и-удаление-строк-дата-фрейма-через-rows_.html","id":"код-4","chapter":"Урок 5 Добавление, изменение и удаление строк дата фрейма через rows_*()","heading":"5.3 Код","text":"","code":"\n#devtools::install_github(\"tidyverse/dplyr\")\nlibrary(dplyr)\n\n# summarise + .groups\nstarwars %>% \n  group_by(homeworld, species) %>% \n  summarise(n = n())\n\n## аргумент .groups\n### .groups = \"drop_last\" удалит последнюю группу\n### .groups = \"drop\" удалит всю группировку\n### .groups = \"keep\" созранит всю группировку\n### .groups = \"rowwise\" разобъёт фрейм на группы как rowwise()\n\n# rows_*()\n## rows_update(x, y) обновляет строки в таблице x найденные в таблице y\n## rows_patch(x, y) работает аналогично rows_update() но заменяет только NA\n## rows_insert(x, y) добавляет строки в таблицу x из таблицы y\n## rows_upsert(x, y) обновляет найденные строки в x и добавляет не найденные из таблицы y\n## rows_delete(x, y) удаляет строки из x найденные в таблице y.\n\n# Создаём тестовые данные\ndf <- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2)\ndf\n\nnew <- tibble(a = c(4, 5), b = c(\"d\", \"e\"), c = c(3.5, 4.5))\nnew\n\n# БАзовые примеры\n## добавляем новые строки\ndf %>% rows_insert(new)\n\n## row_insert вернёт ошибку если мы попытаемся добавить уже существующую строку\ndf %>% rows_insert(tibble(a = 3, b = \"c\"))\n\n## если вы хотите обновить существующее значение необходимо использовать row_update\ndf %>% rows_update(tibble(a = 3, b = \"c\"))\n\n## но rows_update вернёт ошибку если вы попытаетесь обновить несуществующее значание\ndf %>% rows_update(tibble(a = 4, b = \"d\"))\n\n## rows_patch заполнит только пропущенные значения по ключу\ndf %>% \n  rows_patch(tibble(a = 2:3, b = \"B\"))\n\n## rows_upsert также вы можете добавлять новые и заменять существуюие значения \n## функцией rows_upsert\ndf %>% \n  rows_upsert(tibble(a = 3, b = \"c\")) %>% \n  rows_upsert(tibble(a = 4, b = \"d\"))\n\n# ################################\n# РАЗБЕРЁМ Аргументы немного более подробно\nset.seed(555)\n\n# менеджеры\nmanagers <- c(\"Paul\", \"Alex\", \"Tim\", \"Bill\", \"John\")\n# товары\nproducts <- tibble(name  = paste0(\"product_\", LETTERS), \n                   price = round(runif(n = length(LETTERS), 100, 400), 0))\n\n# функция генерации купленных товаров\nprod_list <- function(prod_list, size_min, size_max) {\n  \n  prod <- tibble(product = sample(prod_list, \n                                  size = round(runif(1, size_min, size_max), 0) ,\n                                  replace = F))\n    return(prod)\n}\n\n\n# генерируем продажи\nsales <- tibble(id         = 1:200,\n                manager_id = sample(managers, size = 200, replace = T),\n                refund     = FALSE,\n                refund_sum = 0)\n\n# генерируем списки купленных товаров\nsale_proucts <-\n    sales %>%\n      rowwise(id) %>%\n      summarise(prod_list(products$name, 1, 6)) %>%\n      left_join(products, by = c(\"product\" = \"name\"))\n  \n# объединяем продажи с товарами\nsales <- left_join(sales, sale_proucts, by = \"id\")\n\n# возвраты\nrefund <- sample_n(sales, 25) %>%\n          mutate( refund = TRUE,\n                  refund_sum = price * 0.9) %>%\n          select(-price, -manager_id) \n\n# отмечаем возвраты в таблице продаж\nsales %>%\n  rows_update(refund)\n\n# аргумент by\nresult <-\n  sales %>%\n    rows_update(refund, by = c(\"id\", \"product\"))"},{"path":"добавление-изменение-и-удаление-строк-дата-фрейма-через-rows_.html","id":"упражнение-1","chapter":"Урок 5 Добавление, изменение и удаление строк дата фрейма через rows_*()","heading":"5.4 Упражнение","text":"В этот раз вам необходимо будет рассчитать зарплату 6ти сотрудников.Для получения тестовых данных выполните приведённый ниже пример кода:В результате вы сформировали 5 таблиц:salary - зарплатная ведомость от бухгалтерии, бухгалтерия знает только данные о ставках сотрудников;bonus - бонусы, которые выписали руководители отделов сотрудникам;penalty - штрафы, которые выписали руководители отделов;new - таблица с 6 сотрудником, он новичёк и бухгалтерия забыла внести его сразу в основную ведомость;time_rate - данные о фактически отработанном времени сотрудника з амесяц.Ваша задача расчитать фактическую запрлату каждого сотрудника по формуле total = rate * time_rate + bonus - penalty.Итоговая таблица при правильном расчёте будет иметь следующий вид:","code":"\nlibrary(dplyr)\n\n# зарплатная ведомость со ставками от бухгалтерии\nsalary <- tibble(\n  employee_id = 1:5,\n  rate        = c(1000, 1200, 700, 1500, 2000),\n  bonus       = rep(0, 5),\n  penalty     = rep(0, 5)\n)\n\n# бонусы от руководителей отделов\nbonus <- tibble(\n  employee_id = c(3, 5),\n  bonus = c(100, 500)\n)\n\n# штрафы от руководителей отделов\npenalty <- tibble(\n  employee_id = c(1, 4, 5),\n  penalty = c(150, 320, 80)\n)\n\n# внесение нового сотрудника в ведомость\nnew <- tibble(\n  employee_id = 6,\n  rate = 500,\n  bonus = 0,\n  penalty = 0\n)\n\n# корректировки ставки по фактически выработанному времени\ntime_rate <- tibble(\n  employee_id = 1:6, \n  time_rate = c(1, 1, 1, 0.8, 1, 0.5)\n)# A tibble: 6 x 6\n  employee_id  rate bonus penalty time_rate total\n        <dbl> <dbl> <dbl>   <dbl>     <dbl> <dbl>\n1           1  1000     0     150       1     850\n2           2  1200     0       0       1    1200\n3           3   700   100       0       1     800\n4           4  1500     0     320       0.8   880\n5           5  2000   500      80       1    2420\n6           6   500     0       0       0.5   250"},{"path":"решения-заданий.html","id":"решения-заданий","chapter":"Решения заданий","heading":"Решения заданий","text":"","code":""},{"path":"решения-заданий.html","id":"задания-к-первому-уроку","chapter":"Решения заданий","heading":"Задания к первому уроку","text":"Выберите все столбцы, которые заканчиваются на Width.Переместите с помощью функции relocate() единственный текстовый столбец в левую часть таблицы.Замените с помощью функции rename_with() в названии столбцов точку на нижнее подчёркивание, и преобразуйте имена в нижний регистр.","code":"\nlibrary(dplyr)\n#> \n#> Attaching package: 'dplyr'\n#> The following objects are masked from 'package:stats':\n#> \n#>     filter, lag\n#> The following objects are masked from 'package:base':\n#> \n#>     intersect, setdiff, setequal, union\n\nselect(iris, ends_with('Width')) %>% \n  tibble()\n#> # A tibble: 150 × 2\n#>    Sepal.Width Petal.Width\n#>          <dbl>       <dbl>\n#>  1         3.5         0.2\n#>  2         3           0.2\n#>  3         3.2         0.2\n#>  4         3.1         0.2\n#>  5         3.6         0.2\n#>  6         3.9         0.4\n#>  7         3.4         0.3\n#>  8         3.4         0.2\n#>  9         2.9         0.2\n#> 10         3.1         0.1\n#> # … with 140 more rows\n#> # ℹ Use `print(n = ...)` to see more rows\nrelocate(iris, where(is.factor)) %>% \n  tibble()\n#> # A tibble: 150 × 5\n#>    Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n#>    <fct>          <dbl>       <dbl>        <dbl>       <dbl>\n#>  1 setosa           5.1         3.5          1.4         0.2\n#>  2 setosa           4.9         3            1.4         0.2\n#>  3 setosa           4.7         3.2          1.3         0.2\n#>  4 setosa           4.6         3.1          1.5         0.2\n#>  5 setosa           5           3.6          1.4         0.2\n#>  6 setosa           5.4         3.9          1.7         0.4\n#>  7 setosa           4.6         3.4          1.4         0.3\n#>  8 setosa           5           3.4          1.5         0.2\n#>  9 setosa           4.4         2.9          1.4         0.2\n#> 10 setosa           4.9         3.1          1.5         0.1\n#> # … with 140 more rows\n#> # ℹ Use `print(n = ...)` to see more rows\nrenamer <- function(x) gsub('\\\\.', '\\\\_', x) %>% tolower()\nrename_with(iris, renamer) %>% \n  tibble()\n#> # A tibble: 150 × 5\n#>    sepal_length sepal_width petal_length petal_width species\n#>           <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n#>  1          5.1         3.5          1.4         0.2 setosa \n#>  2          4.9         3            1.4         0.2 setosa \n#>  3          4.7         3.2          1.3         0.2 setosa \n#>  4          4.6         3.1          1.5         0.2 setosa \n#>  5          5           3.6          1.4         0.2 setosa \n#>  6          5.4         3.9          1.7         0.4 setosa \n#>  7          4.6         3.4          1.4         0.3 setosa \n#>  8          5           3.4          1.5         0.2 setosa \n#>  9          4.4         2.9          1.4         0.2 setosa \n#> 10          4.9         3.1          1.5         0.1 setosa \n#> # … with 140 more rows\n#> # ℹ Use `print(n = ...)` to see more rows"},{"path":"решения-заданий.html","id":"задания-ко-второму-уроку","chapter":"Решения заданий","heading":"Задания ко второму уроку","text":"Используйте функцию across(), и разделите значения полей имена которых заканчиваются на Length на среднее значение по этим же столбцам.Посчитайте среднее значение столбцов, имена которых начинаются на Sepal сгруппировав данные по столбцу Species.","code":"\nlibrary(dplyr)\n\nmutate(iris, across(ends_with('Length'), ~ . / mean(.))) %>% \n  tibble()\n#> # A tibble: 150 × 5\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#>           <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n#>  1        0.873         3.5        0.373         0.2 setosa \n#>  2        0.839         3          0.373         0.2 setosa \n#>  3        0.804         3.2        0.346         0.2 setosa \n#>  4        0.787         3.1        0.399         0.2 setosa \n#>  5        0.856         3.6        0.373         0.2 setosa \n#>  6        0.924         3.9        0.452         0.4 setosa \n#>  7        0.787         3.4        0.373         0.3 setosa \n#>  8        0.856         3.4        0.399         0.2 setosa \n#>  9        0.753         2.9        0.373         0.2 setosa \n#> 10        0.839         3.1        0.399         0.1 setosa \n#> # … with 140 more rows\n#> # ℹ Use `print(n = ...)` to see more rows\ngroup_by(iris, Species) %>% \n  summarise(across(starts_with('Sepal'), mean))\n#> # A tibble: 3 × 3\n#>   Species    Sepal.Length Sepal.Width\n#>   <fct>             <dbl>       <dbl>\n#> 1 setosa             5.01        3.43\n#> 2 versicolor         5.94        2.77\n#> 3 virginica          6.59        2.97"},{"path":"решения-заданий.html","id":"заданиe-к-третьему-уроку","chapter":"Решения заданий","heading":"Заданиe к третьему уроку","text":"Ваша задача не переворачивая таблицу, добавить в неё 4 столбца:winter_avg_sales - средний объём продаж за зимные месяца;spring_avg_sales - средний объём продаж за весенние месяца;summer_avg_sales - средний объём продаж за летние месяца;autumn_avg_sales - средний объём продаж за осенние месяца;И оставить из исходной таблицы только столбец с обозначением года, и рассчитанные на предыдущем шаге столбцы.Решение:","code":"\nlibrary(dplyr)\n\nrowwise(sales) %>% \n  mutate(\n    winter_avg_sales = mean(Dec, Jan, Feb),\n    spring_avg_sales = mean(c_across(Mar:May)),\n    summer_avg_sales = mean(c_across(Jun:Aug)),\n    autumn_avg_sales = mean(c_across(Sep:Nov))\n  ) %>% \n  select(year, matches('avg'))\n#> # A tibble: 6 × 5\n#> # Rowwise: \n#>    year winter_avg_sales spring_avg_sales summer_a…¹ autum…²\n#>   <int>            <dbl>            <dbl>      <dbl>   <dbl>\n#> 1  2000              297             215.       243     276 \n#> 2  2001              263             248.       272     225.\n#> 3  2002              187             241.       189     289 \n#> 4  2003              234             309        305.    206.\n#> 5  2004              183             220        301.    290.\n#> 6  2005              273             273        275.    252.\n#> # … with abbreviated variable names ¹​summer_avg_sales,\n#> #   ²​autumn_avg_sales"},{"path":"решения-заданий.html","id":"заданиe-к-четвёртому-уроку","chapter":"Решения заданий","heading":"Заданиe к четвёртому уроку","text":"Сгенерируйте согласно этим параметрам таблицу содержащую в столбце sim номер строки таблицы параметров, а в столбце val сами значения случайных распределений. Для воспроизводимости результатов установите счётчик генерации случайных чисел в позиции 400 (set.seed(400)). Тогда итоговый результат будет иметь следующий вид:Решение:","code":"\nlibrary(dplyr)\nset.seed(400)\n\nparams %>%\n   rowwise(sim) %>%\n   summarise(val = rnorm(n, mean, sd))\n#> `summarise()` has grouped output by 'sim'. You can override\n#> using the `.groups` argument.\n#> # A tibble: 21 × 2\n#> # Groups:   sim [3]\n#>      sim    val\n#>    <dbl>  <dbl>\n#>  1     1  -4.18\n#>  2     1   4.08\n#>  3     1   8.36\n#>  4     1  -2.41\n#>  5     2  -4.02\n#>  6     2 -11.5 \n#>  7     2  10.6 \n#>  8     2   9.20\n#>  9     2   3.08\n#> 10     2  -3.75\n#> # … with 11 more rows\n#> # ℹ Use `print(n = ...)` to see more rows"},{"path":"решения-заданий.html","id":"заданиe-к-пятому-уроку","chapter":"Решения заданий","heading":"Заданиe к пятому уроку","text":"Ваша задача расчитать фактическую запрлату каждого сотрудника по формуле total = rate * time_rate + bonus - penalty.Решение:","code":"\nlibrary(dplyr)\n\nrows_update(salary, bonus, by = 'employee_id') %>% \n  rows_update(penalty, by = 'employee_id') %>% \n  rows_insert(new, by = 'employee_id') %>% \n  left_join(time_rate, by = 'employee_id') %>% \n  mutate(total = rate * time_rate + bonus - penalty)\n#> # A tibble: 6 × 6\n#>   employee_id  rate bonus penalty time_rate total\n#>         <int> <dbl> <dbl>   <dbl>     <dbl> <dbl>\n#> 1           1  1000     0     150       1     850\n#> 2           2  1200     0       0       1    1200\n#> 3           3   700   100       0       1     800\n#> 4           4  1500     0     320       0.8   880\n#> 5           5  2000   500      80       1    2420\n#> 6           6   500     0       0       0.5   250"},{"path":"заключение.html","id":"заключение","chapter":"Заключение","heading":"Заключение","text":"Надеюсь данный мини курс по введению в dplyr 1.0.0 был вам полезен, рассмотренный в нём релиз содержал действительно много полезных доработок и новых функций.Буду рад видеть вас среди подписчиков моего Telegram и YouTube канала.","code":""}]
